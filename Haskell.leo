<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet ekr_test?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.697640117994">
	<global_window_position top="20" left="102" height="678" width="912"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="andelf.20071221104823" str_leo_pos="1,0,13,0"><vh>@chapters</vh></v>
<v t="andelf.20071222000447" a="EV"><vh>Haskell</vh>
<v t="andelf.20071221105546" a="T"><vh>Hackell笔记</vh>
<v t="andelf.20071221110609"><vh>第一章</vh></v>
<v t="andelf.20071221105546.1"><vh>第二章</vh>
<v t="andelf.20071221111927"><vh>第一个 Haskell 程序</vh></v>
<v t="andelf.20071221111927.1"><vh>使用 Hugs</vh></v>
<v t="andelf.20071221112314"><vh>标准 Prelude 和 Haskell 库</vh></v>
<v t="andelf.20071221112314.1"><vh>模块</vh></v>
<v t="andelf.20071221120524"><vh>第二个例子: 图片</vh></v>
<v t="andelf.20071221120524.1"><vh>错误和错误信息</vh></v>
</v>
<v t="andelf.20071221121436"><vh>第三章 基本类型和定义</vh>
<v t="andelf.20071221122121"><vh>布尔值: Bool</vh></v>
<v t="andelf.20071221122121.1"><vh>整数: Int</vh></v>
<v t="andelf.20071221122121.2"><vh>重载</vh></v>
<v t="andelf.20071221235026"><vh>Guard</vh></v>
<v t="andelf.20071222074336"><vh>字符: Char</vh></v>
<v t="andelf.20071222082135"><vh>浮点数: Float</vh></v>
<v t="andelf.20071222093935"><vh>语法</vh></v>
</v>
<v t="andelf.20071222102247"><vh>第四章 设计并编写程序</vh>
<v t="andelf.20071222102247.1"><vh>从哪里开始? 在 Haskell 中设计一个程序</vh></v>
<v t="andelf.20071222110059"><vh>递归</vh></v>
<v t="andelf.20071222110059.1"><vh>原始递归</vh></v>
<v t="andelf.20071222110059.2"><vh>递归的一般格式</vh></v>
<v t="andelf.20071222110059.3"><vh>程序测试</vh></v>
</v>
<v t="andelf.20071223173338"><vh>第五章 数据类型: 元组和列表</vh>
<v t="andelf.20071223173338.1"><vh>介绍元组, 列表和字符串</vh></v>
<v t="andelf.20071223173338.2"><vh>元组类型</vh></v>
<v t="andelf.20071223173338.3"><vh>我们如何操作列表</vh></v>
<v t="andelf.20071223173338.4"><vh>Haskell 中的列表</vh></v>
<v t="andelf.20071223173338.5"><vh>List comprehensions</vh></v>
<v t="andelf.20071223173338.6"><vh>一个图书馆数据库</vh></v>
<v t="andelf.20071223173338.7"><vh>通用函数: polymorphism</vh></v>
<v t="andelf.20071223173338.8"><vh>Prelude.hs 中的 Haskell 列表函数</vh></v>
<v t="andelf.20071223173338.9"><vh>字符串类型</vh></v>
</v>
<v t="andelf.20071224221752"><vh>第六章 用列表编程</vh>
<v t="andelf.20071224221752.1"><vh>Picture 例子</vh></v>
<v t="andelf.20071224221752.2"><vh>扩展例子: 位置图片</vh></v>
<v t="andelf.20071224221752.3"><vh>局部定义</vh></v>
<v t="andelf.20071224221752.4"><vh>扩展例子: 超市帐单</vh></v>
</v>
<v t="andelf.20071225212727"><vh>第七章 定义列表函数</vh>
<v t="andelf.20071225212727.1"><vh>模式匹配</vh></v>
<v t="andelf.20071225212727.2"><vh>列表和列表模式</vh></v>
<v t="andelf.20071225212727.3"><vh>初等递归列表</vh></v>
<v t="andelf.20071225212727.4"><vh>寻找初等递归定义</vh></v>
<v t="andelf.20071225212727.5"><vh>通用列表递归</vh></v>
<v t="andelf.20071225212727.6"><vh>例子: 文本处理</vh></v>
</v>
<v t="andelf.20071226145256"><vh>第八章 程序论证</vh>
<v t="andelf.20071226145256.1"><vh>如何理解函数定义</vh></v>
<v t="andelf.20071226145256.2"><vh>测试和证明</vh></v>
<v t="andelf.20071226145256.3"><vh>定义, 终止和有限性</vh></v>
<v t="andelf.20071226145256.4"><vh>逻辑</vh></v>
<v t="andelf.20071226145256.5"><vh>介绍</vh></v>
<v t="andelf.20071226145256.6"><vh>归纳法证明的例子</vh></v>
<v t="andelf.20071226145256.7"><vh>一般化证明目标</vh></v>
</v>
<v t="andelf.20071226175906"><vh>第九章 概括: 计算的模式</vh>
<v t="andelf.20071226175906.1"><vh>列表处理的模式</vh></v>
<v t="andelf.20071226175906.2"><vh>高阶函数: 作为参数的函数</vh></v>
<v t="andelf.20071226175906.3"><vh>折叠和原始递归</vh></v>
<v t="andelf.20071226175906.4"><vh>概括: 分割列表</vh></v>
</v>
<v t="andelf.20071229073739"><vh>弟十章 函数和值</vh>
<v t="andelf.20071229073739.1"><vh>函数级别定义</vh></v>
<v t="andelf.20071229073739.2"><vh>函数创建</vh></v>
<v t="andelf.20071229073739.3"><vh>函数作为值和结果</vh></v>
<v t="andelf.20071229073739.4"><vh>部分应用</vh></v>
<v t="andelf.20071229073739.5"><vh>复习 Picture 例子</vh></v>
<v t="andelf.20071229073739.6"><vh>更多例子</vh></v>
<v t="andelf.20071229073739.7"><vh>currying 和 uncurrying</vh></v>
<v t="andelf.20071229073825"><vh>l例子: 创建一个索引</vh></v>
<v t="andelf.20080104104355"><vh>检查 通用函数</vh></v>
</v>
<v t="andelf.20080104105224"><vh>第十一章 程序开发</vh>
<v t="andelf.20080104105224.1" a="M"><vh>开发周期</vh></v>
<v t="andelf.20080104110304" a="M"><vh>开发实习</vh></v>
</v>
<v t="andelf.20080109210844"><vh>第十二章 重载和类型类</vh>
<v t="andelf.20080109210844.1"><vh>为什么要重载</vh></v>
<v t="andelf.20080109210844.2"><vh>介绍类</vh></v>
<v t="andelf.20080109210844.3"><vh>签名和实例 signature 和 instance</vh></v>
<v t="andelf.20080109210844.4"><vh>内建 Haskell 类</vh></v>
<v t="andelf.20080109210844.5"><vh>类型和类</vh></v>
</v>
<v t="andelf.20090716095801.1530"><vh>第十三章 检查类型</vh>
<v t="andelf.20090716095801.1531"><vh>单一类型检查</vh></v>
<v t="andelf.20090716095801.1532"><vh>多态类型检查</vh></v>
</v>
<v t="andelf.20090716095801.1535"><vh>第十四章 代数类型</vh>
<v t="andelf.20090716095801.1536"><vh>代数类型介绍</vh></v>
</v>
<v t="andelf.20071222081313"><vh>习题</vh>
<v t="andelf.20071223173338.10"><vh>Chpt 3</vh>
<v t="andelf.20071221124714.1"><vh>Exe 3.1</vh></v>
<v t="andelf.20071222072729"><vh>Exe 3.11</vh></v>
<v t="andelf.20071222081313.1"><vh>Exe  3.12</vh></v>
<v t="andelf.20071222081640"><vh>Exe 3.13</vh></v>
<v t="andelf.20071222085831"><vh>Exe 3.14</vh></v>
<v t="andelf.20071222093303"><vh>Exe 3.15 Exe 3.16</vh></v>
</v>
<v t="andelf.20071223173338.11"><vh>Chpt 4</vh>
<v t="andelf.20071222110939"><vh>Exe 4.1</vh></v>
<v t="andelf.20071222111309"><vh>Exe 4.2</vh></v>
<v t="andelf.20071223075150"><vh>Exe 4.5</vh></v>
<v t="andelf.20071223075903"><vh>Exe 4.6</vh></v>
<v t="andelf.20071223081547"><vh>Exe 4.7</vh></v>
<v t="andelf.20071223083648"><vh>Exe 4.8</vh></v>
<v t="andelf.20071223090117"><vh>Exe 4.9</vh></v>
<v t="andelf.20071223092734"><vh>Exe 4.10</vh></v>
<v t="andelf.20071223094140"><vh>Exe 4.12</vh></v>
<v t="andelf.20071223164132"><vh>Exe 4.13</vh></v>
<v t="andelf.20071223164132.1"><vh>Exe 4.14</vh></v>
<v t="andelf.20071223170803"><vh>Exe 4.15</vh></v>
<v t="andelf.20071223170803.1"><vh>Exe 4.16</vh></v>
<v t="andelf.20071223170803.2"><vh>Exe 4.17</vh></v>
<v t="andelf.20071223170803.3"><vh>Exe 4.18</vh></v>
</v>
<v t="andelf.20071223213358"><vh>Chpt 5</vh>
<v t="andelf.20071223213358.1"><vh>Exe 5.1</vh></v>
<v t="andelf.20071224103310"><vh>Exe 5.5</vh></v>
<v t="andelf.20071224103342"><vh>Exe 5.6</vh></v>
<v t="andelf.20071224103650"><vh>Exe 5.7</vh></v>
<v t="andelf.20071224110147"><vh>Exe 5.8</vh></v>
<v t="andelf.20071224110648"><vh>Exe 5.9</vh></v>
<v t="andelf.20071224120021"><vh>Exe 5.10</vh></v>
<v t="andelf.20071224120021.1"><vh>Exe 5.11</vh></v>
<v t="andelf.20071224171541"><vh>Exe 5.16</vh></v>
<v t="andelf.20071224171541.1"><vh>Exe 5.17</vh></v>
<v t="andelf.20071224171709"><vh>Exe 5.18</vh></v>
<v t="andelf.20071224220411"><vh>Exe 5.23</vh></v>
</v>
<v t="andelf.20071225180210"><vh>Chpt 6</vh>
<v t="andelf.20071225180210.1"><vh>Exe 6.8</vh></v>
</v>
<v t="andelf.20071225223038"><vh>Chpt 7</vh>
<v t="andelf.20071225223038.1"><vh>Exe 7.2</vh></v>
<v t="andelf.20071226064144"><vh>Exe 7.4</vh></v>
<v t="andelf.20071226064601"><vh>Exe 7.5</vh></v>
<v t="andelf.20071226071724"><vh>Exe 7.6</vh></v>
<v t="andelf.20071226120801"><vh>Exe 7.14</vh></v>
<v t="andelf.20071226135648"><vh>Exe 7.26</vh></v>
</v>
<v t="andelf.20071226150057"><vh>Chpt 8</vh>
<v t="andelf.20071226150057.1"><vh>Exe 8.1</vh></v>
<v t="andelf.20071226150057.2"><vh>Exe 8.2</vh></v>
</v>
<v t="andelf.20071228063723"><vh>Chpt 9</vh>
<v t="andelf.20071228063723.1"><vh>Exe 9.3</vh></v>
<v t="andelf.20071228063856"><vh>Exe 9.4</vh></v>
<v t="andelf.20071228063945"><vh>Exe 9.5</vh></v>
<v t="andelf.20071228065930"><vh>Exe 9.6</vh></v>
<v t="andelf.20071228065930.1"><vh>Exe 9.7</vh></v>
<v t="andelf.20071228070341"><vh>Exe 9.9</vh></v>
</v>
<v t="andelf.20071231155131"><vh>Chpt 10</vh>
<v t="andelf.20071231155131.1"><vh>Exe 10.7</vh></v>
<v t="andelf.20080101075405"><vh>Exe 10.8</vh></v>
<v t="andelf.20080101081923"><vh>Exe 10.9</vh></v>
<v t="andelf.20080101082514"><vh>Exe 10.10</vh></v>
<v t="andelf.20080101083309"><vh>Exe 10.11</vh></v>
<v t="andelf.20080102162808"><vh>Exe 10.13</vh></v>
<v t="andelf.20080104104736"><vh>Exe 10.33</vh></v>
<v t="andelf.20080104104736.1"><vh>Exe 10.34</vh></v>
</v>
<v t="andelf.20080111114655"><vh>Chpt 12</vh>
<v t="andelf.20080111114655.1"><vh>Exe 12.1</vh></v>
<v t="andelf.20080113222955"><vh>Exe 12.5</vh></v>
<v t="andelf.20080113221441"><vh>Exe 12.6</vh></v>
</v>
<v t="andelf.20090716095801.1533"><vh>Chpt 13</vh>
<v t="andelf.20090716095801.1534"><vh>13.1</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="andelf.20071221104823"></t>
<t tx="andelf.20071221105546">
@tabwidth -4
@pagewidth 80
</t>
<t tx="andelf.20071221105546.1">





</t>
<t tx="andelf.20071221110609">内建类型

Char Int Integer String 等</t>
<t tx="andelf.20071221111927">代码文件格式有 hs 文件和 lhs 文件


注释行以 -- 开头 
多行注释 {- -}

lhs 文件中代码行以 &gt; 表示</t>
<t tx="andelf.20071221111927.1">命令: 
:load XXX
:reload [filnename]
:edit XXX.hs
:type exp
:info name
:find name
:browse [all][module...]
:quit
:?
!shellcommand

可用首字母缩写

使用 :set 设置编辑器

$$ 代表最近一次函数调用
</t>
<t tx="andelf.20071221112314">标准 prelude 库和 Haskell 库

/hugs/lib/Prelude.hs
也被分成了一些小的模块, 同时 Haskell 也提供了一些第三方贡献库
</t>
<t tx="andelf.20071221112314.1">每个文件一个模块

- 一个模块有一个指定的名字, 包含一系列 Haskell 定义
- 文件名和模块名必须一致 Blah.hs 或 Blah.lhs 必须包含 Blah 模块
- 模块机制为库的组织提供了支持

命令行提示符显示当前模块, 例如 Main&gt;
module Ant where
    ...

module Bee where
import Ant
...
</t>
<t tx="andelf.20071221120524"></t>
<t tx="andelf.20071221120524.1">语法错误
类型错误
 - term 的类型是 type 与 does not math 不匹配
 - 查看 term 的类型是否匹配
程序错误
</t>
<t tx="andelf.20071221121436"></t>
<t tx="andelf.20071221122121">True 和 False

&amp;&amp;    and
||    or
not    not

# Bool -&gt; Bool -&gt; Bool 类型
==  等于
/=  不等于

例, 异或的定义:

exOr :: Bool -&gt; Bool -&gt; Bool
exOr x y = (x || y) &amp;&amp; not (x &amp;&amp; y)

# 或是

exOr True x = not x
exOr False x = x

# 自定义的 Not

myNot :: Bool -&gt; Bool
myNot True  = False
myNot False = True

</t>
<t tx="andelf.20071221122121.1">Int:
    -2147483648 ~ 2147483647
Integer:
    任意大小

运算符:
    +
    *
    ^ 乘方
    -
    div 除以, 例如 div 14 3 为 4 , 也可写做 14 `div` 3
    mod 取模
    abs 绝对值
    negate 改变符号

为什么要有 negeate , 函数调用 func -34 会被解释为 func 减去 34 , 也可以使用括号
`xxx` 函数, infix version 插入

相关运算符

&gt;
&gt;=
==
/=
&lt;=
&lt;












</t>
<t tx="andelf.20071221122121.2">例如在 Bool 和 Int 比较中的 == 可能是这样的类型

Int -&gt; Int -&gt; Int
Bool -&gt; Bool -&gt; Bool 

也就是说 == 操作符被重载了
即:
    t -&gt; t -&gt; Bool</t>
<t tx="andelf.20071221124714.1">exOr :: Bool -&gt; Bool -&gt; Bool
exOr True y = not y
exOr False y = y

# 或

exOr :: Bool -&gt; Bool -&gt; Bool
exOr x y = ((not x &amp;&amp; y) || (x &amp;&amp; not y)) &amp;&amp; not (x &amp;&amp; y)</t>
<t tx="andelf.20071221235026">也就是布尔表达式
例如 Prelude 中的

max :: Int -&gt; Int -&gt; Int
max x y
    | x &gt;= y     = x
    | otherwise  = y

第一个 guard 为 (x&gt;= y)
第二个 guard 为 otherwise 其实就是一个 Bool True 

可以有多个 guard , guard 为 True 时, 函数返回 guard 对应的值

按行展开的方法
max 4 3
    ?? 4 &gt;= 3
    ?? ~&gt; True
~&gt; 4

max 3 4
    ?? 3 &gt;= 4
    ?? ~&gt; False
    ?? otherwise
    ?? ~&gt; True
~&gt; 4

条件表达式

if condition them m else n

例如

max :: Int -&gt; Int -&gt; Int
max x y
    = if x &gt;= y then x else y

如何避免"定义与导入冲突"
使用
import Prelude hiding (max, min)</t>
<t tx="andelf.20071222000447">
@silent
@all
@language haskell</t>
<t tx="andelf.20071222072729">minThree :: Int -&gt; Int -&gt; Int -&gt; Int
minThree x y z 
    | x &lt;= y &amp;&amp; x &lt;= z	= x
    | z &lt;= y		= z
    | otherwise		= y

-- 第一个 guard 保证了 x &gt; y</t>
<t tx="andelf.20071222074336">使用单引号表示

tab        '\t'
newline    '\n'
backslash    '\\'
single quote    '\''
double quote    '"'
...

字符串方法 
import Char 
ord :: Char -&gt; Int
chr :: Int -&gt; Char
...

使用 :b Char 可查看 </t>
<t tx="andelf.20071222081313"></t>
<t tx="andelf.20071222081313.1">--change letters
trans :: Char -&gt; Char
trans ch
    | isAlpha ch &amp;&amp; isLower ch = toUpper ch
    | otherwise		    = ch</t>
<t tx="andelf.20071222081640">charToNum :: Char -&gt; Int
charToNum ch
    | ch &gt;= '1' &amp;&amp; ch &lt;= '9'	= ord ch - ord '0'
    | otherwise			= 0</t>
<t tx="andelf.20071222082135">Number with fractional part

Double 的精度比 Float 要高
全精度分数使用建立在 Integer 上的 Rational 

为什么叫 Float ?
小数点位置不确定, 浮动的

相关运算符和函数

+ - * /
^   Float -&gt; Int -&gt; Float
**  Float -&gt; Float -&gt; Float
== /= &lt; &gt; &lt;= &gt;=
abs
acos asin atan
ceiling floor round
cos sin tan
exp 
fromInt 转换函数, 需要 import Hugs.Prelude
log 以 e 为底
logBase     Float -&gt; Float -&gt; Float
negate
pi
signum      Float -&gt; Float 返回 1.0 0.0 或 -1.0
sqrt

为什么需要这里的 fromInt?
Main&gt; (floor 5.6) + 6.7
ERROR - Unresolved overloading
*** Type       : (Fractional a, Integral a) =&gt; a
*** Expression : floor 5.6 + 6.7
Main&gt; fromInt(floor 5.6) + 6.7
11.7

记法:
    213.64e7
    -435e-4
    1.345e+43

重载
Haskell 中的数字整数既是 Int 又是 Float
以及一些运算函数也是重载的


</t>
<t tx="andelf.20071222085831">averageThree :: Int -&gt; Int -&gt; Int -&gt; Float
averageThree x y z = fromInt (x + y + z)/ 3.0

howManyAboveAverage x y z
    | fromInt x &gt; averageThree x y z &amp;&amp; fromInt y &gt; averageThree x y z	= 2
    | fromInt y &gt; averageThree x y z &amp;&amp; fromInt z &gt; averageThree x y z	= 2
    | otherwise	    = 1

</t>
<t tx="andelf.20071222093303">-- solve quadratic equation
delta :: Float -&gt; Float -&gt; Float -&gt; Float
delta a b c = b * b - (4 * a * c)

howManyRoots :: Float -&gt; Float -&gt; Float -&gt; Int
howManyRoots a b c
    | a /= 0 &amp;&amp; delta a b c&gt; 0   = 2
    | a /= 0 &amp;&amp; delta a b c== 0  = 1
    | a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0    = -1 -- every real
    | a == 0 &amp;&amp; b /= 0	    = 1
    | otherwise = 0 -- delta &lt; 0 and a=b=0 c!=0</t>
<t tx="andelf.20071222093935">相同缩近或更左的文本终止一个定义
例如

mystery x = x*x
    +x
        +2
next x = ...

Haskell 可以使用 ; 标记语句结束

程序的布局

fun v1 v2 ... vn
    | g1        = e1
    | g2        = e2
    ...
    | otherwise = er

fun v1 v2 ... vn
    | a long guard which may
      go over a number of lines
        = very long expression which goes
          over a number of lines
    | g2        = e2
    ...

Haskell 中的名字
identifiers 标识符 必须以字母开始, 可以是任意字母, 数字, 下划线, 以及单引号
用于变量和类型变量的名字必须以小写字母开头
大写字母开头的标识符用于类型名

保留字:
    case class data default deriving do else if import in infix
    infixl infixr instance let module newtype of them type where
另外 hiding 有特殊意义, 但不是保留字

一般使用类似 maxThree 这样的命名方式

重定义与 Prelude 中重名的函数要隐藏原函数 redefine hide

Haskell 建立在 Unicode 字符上, 可以使用 ASCII 以外的符号

运算符
运算符是 infix 插入函数, 所以它们可以写在参数中
运算符的结合性, 优先级 binding power

注意:
    f n+1 被解释为 (f n)+1
    f -12 被解释为 (f) - 12

插入 infix
(+) :: Int -&gt; Int -&gt; Int
(+) 2 3 = 2 + 3

2 `max` 3 = max 2 3

自定义运算符:
    你可以自定义 infix 运算符
    ! # $ % &amp; * + . / &lt; = &gt; ? \ ^ | : - ~ 以及其他 Unicode 符号
    类似:
        (&amp;&amp;&amp;) :: Int -&gt; Int -&gt; Int
        x &amp;&amp;&amp; y
            | x &gt; y     = y
            | otherwise = x



</t>
<t tx="andelf.20071222102247"></t>
<t tx="andelf.20071222102247.1">设计 design

定义: 设计是开始写详细的 Haskell 代码之前的阶段

我明白我需要做什么么?
 + 简单的问题也需要在编程前考虑
 + 有些时候是没有正确的答案的
 + 想想在不同的例子下它如何得出结果

我可以在这个阶段考虑类型相关的东西么?

我已经知道些什么? 我如何使用这些信息?
我们需要知道当前有那些可供解决问题的资源: 已经完成的定义, 语言的 Prelude 为我们提供了哪些.
例如之前的 maxTree , 我们知道 Prelude 中已经提供了 max 函数, 这便是一个可利用的资源
有了这些资源, 如何利用呢?
 + 我们把这个函数作为我们所要完成任务的模型:
     类比 max 中的 x &gt;= y 和 maxThree 中的 x &gt;= y &amp;&amp; x &gt;= z
 + 我们可以直接在新定义中使用这个函数:
     maxThree x y z = max (max x y) z
     maxThree x y z = (x `max` y) `max` z

我可以把这个问题分解成一些小的简单的部分么?
如果我有了所需要的所有函数, 如何使用呢:
    top-down 自顶向下

</t>
<t tx="andelf.20071222110059">递归, 用函数自己描述自己:
    需要一个起始点
factorial:
    fac 0 = 1
    fac n = fac (n-1) * n

所以我们得到

fac :: Int -&gt; Int
fac n
    | n==0    = 1
    | n&gt;0     = fac (n-1) * n

递归为什么会工作?

未定义的错误值
fac (-2)

fac :: Int -&gt; Int
fac n
    | n==0      = 1
    | n&gt;0       = fac (n-1) * n
    | otherwise = 0
或
    | otherwise = error "fac only defined on naturl numbers"
</t>
<t tx="andelf.20071222110059.1">定义:
    求一个自然数函数, 已知初值 f(0) 和 f(n) 与 f(n-1) 的关系.

(prim: 规矩)
func n
    | n== 0    = ...
    | n&gt; 0     = ... func (n-1)</t>
<t tx="andelf.20071222110059.2">通用递归:
    定义 f(n) 需要哪几个值

Fibonacci 数列
fib : Int -&gt; Int
fib n
    | n==0      = 0
    | n==1      = 1
    | n&gt; 1      = fib (n-2) + fib (n-1)

任何时候都要注意递归不能结束的情况</t>
<t tx="andelf.20071222110059.3">黑箱测试
把输入分成几个测试组, 从每个组中至少选一条输入
同样要注意特殊情况, boundaries , 边界条件, 比如有了正数和负数, 不能忘记 0

例如, 传参顺序不同导致的问题
mysteryMax :: Int -&gt; Int -&gt; Int -&gt; Int
mysteryMax x y z
    | x &gt; y &amp;&amp; y &gt; z    = x
    | y &gt; x &amp;&amp; y &gt; z    = y
    | otherwise         = z

mysteryMax 6 6 2 ~&gt; 2

简单的测试并不能完全保证我们的函数是正确的

白箱测试
测试 guard 中的边界条件, 例如 &gt;= 或 &gt; 
使用了递归的函数, 测试零条件, 为 1 时, 以及一般情况</t>
<t tx="andelf.20071222110939">maxFour :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
maxFour a b c d
    | a &gt;= b &amp;&amp; a &gt;= c &amp;&amp; a &gt;= d    = a
    | b &gt;= c &amp;&amp; b &gt;= d		    = b
    | c &gt;= d			    = c
    | otherwise			    = d

maxFour :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
maxFour a b c d
    = max (max a b) (max c d)

maxFour :: Int -&gt; Int -&gt; Int -&gt; Int -&gt; Int
maxFour a b c d
    = maxThree a b c `max` d</t>
<t tx="andelf.20071222111309">weakAscendingOrder :: Int -&gt; Int -&gt; Int -&gt; Bool
weakAscendingOrder a b c
    = a &lt;= b &amp;&amp; b &lt;= c

between :: Int -&gt; Int -&gt; Int -&gt; Bool
between a b c
    = weakAscendingOrder a b c || weakAscendingOrder c b a</t>
<t tx="andelf.20071223075150">rangeProduct :: Int -&gt; Int -&gt; Int
rangeProduct m n
    | m== n+1	= m * n
    | m== n	= m
    | m&gt; n	= m * rangeProduct (m-1) n
    | otherwise	    = 0
</t>
<t tx="andelf.20071223075903">newfac :: Int -&gt; Int
newfac n
    | n== 0         = 1
    | n&gt; 0          = rangeProduct n 1
    | otherwise     = error "阶乘只用于自然数"</t>
<t tx="andelf.20071223081547">--multiply
mult :: Int -&gt; Int -&gt; Int
mult a b
    | a== 0	    = 0
    | a== 1	    = b
    | otherwise = b + mult (a-1) b</t>
<t tx="andelf.20071223083648">--int square root
find_intSqrt :: Int -&gt; Int -&gt; Int
find_intSqrt n x
    | x^2&lt;= n &amp;&amp; (x+1)^2&gt; n	= x
    | otherwise			= find_intSqrt n (x-1)

intSqrt :: Int -&gt; Int
intSqrt n
    | n&gt;= 0	= find_intSqrt n n
    | otherwise = error "负数无法开平方"</t>
<t tx="andelf.20071223090117">-- max value of a function
maxV :: (Int -&gt; Int) -&gt; Int -&gt; Int
maxV f n
    | n== 0	= f 0
    | n&gt; 0	= max (f n) (maxV f (n-1))
    | otherwise = error "XXXX"

-- test func
test :: Int -&gt; Int
test n = n*n - 100 * n + 134</t>
<t tx="andelf.20071223092734">f :: Int -&gt; Int
f 6 = 0
f _  = 1

hasZero :: Int -&gt; Bool
hasZero n
    | n== 0	    = f 0 == 0
    | f n == 0	    = True
    | otherwise	    = hasZero (n-1)
</t>
<t tx="andelf.20071223094140">cutBlock :: Int -&gt; Int
cutBlock n
    | n== 1	= 2
    | otherwise	= 2 * cutBlock (n-1)</t>
<t tx="andelf.20071223164132">findHighestFactor :: Int -&gt; Int -&gt; Int -&gt; Int
findHighestFactor x y n
    | x `mod` n == 0 &amp;&amp; y `mod` n == 0	    = n
    | otherwise	
	= findHighestFactor x y (n-1)  
highestFactor :: Int -&gt; Int -&gt; Int
highestFactor x y
    | x&gt; 0 &amp;&amp; y&gt; 0 
	= findHighestFactor x y (min x y)</t>
<t tx="andelf.20071223164132.1">myPower :: Int -&gt; Int
myPower n
    | n &lt;  0		= error "Not Supported"
    | n == 0		= 1
    | n == 1		= 2
    | n `mod` 2 == 0	= (^) (myPower (div n 2)) 2
    | n `mod` 2 == 1	= 2 * (^) (myPower (div (n-1) 2)) 2</t>
<t tx="andelf.20071223170803">0 0 0
1 0 0
0 1 0
0 0 1
</t>
<t tx="andelf.20071223170803.1">0 0 0 True
1 0 0
0 1 0
0 0 1</t>
<t tx="andelf.20071223170803.2">0 0 0
1 0 0
0 1 0
0 0 1
1 2 3</t>
<t tx="andelf.20071223170803.3">0 0 0
1 0 0
0 1 0 True
0 0 1
1 2 3 True</t>
<t tx="andelf.20071223173338"></t>
<t tx="andelf.20071223173338.1">元组

("Salt: 1kg", 139) 
(String, Int) 类型

列表

[ ("Salt:  lkg", 139) , ("Plain crisps", 25) , ("Gin:  llt", 1099) ]
[ (Stirng, Int) ] 类型

列表中可以有相同的项

可以定义新的类型 synonym 同义词
type ShopItem = (String, Int)
type Basket   = [ShppItem]

字符串

type String = [Char]

</t>
<t tx="andelf.20071223173338.2">(t1, t2, ... , tn)
(v1, v2, ... , vn)

type 对应 value 

type 定义是一种速记

minAndMax :: Int -&gt; Int -&gt; (Int,Int)
minAndMax x y
    | x&gt;=y      = (y,x)
    | otherwise = (x,y)

模式匹配 pattern matching

addPair :: (Int, Int) -&gt; Int
addPair (x,y) = x+y

或

addPair :: (Int, Int) -&gt; Int
addPair (0,y) = y
addPair (x,y) = x+y

模式匹配可以嵌套

shift :: ((Int,Int),Int)  -&gt;  (Int,(Int,Int)) 
shift ((x,y),z) = (x,(y,z)) 

可以利用新定义的名字

name :: ShopItem -&gt; String

Haskell 有选择器函数

fst (x,y) = x
snd (x,y) = y

可以这样定义函数

addpair :: (Int,Int) -&gt; Int 
addpair p = fst p +  snd p 

例子
fibStep :: (Int,Int) -&gt;  (Int,Int) 
fibStep (u,v) =  (v,u+v) 

fibPair :: Int -&gt; (Int,Int)
fibPair n
    | n==0      = (0,1)
    | otherwise = fibStep (fibPair (n-1))

fastFib :: Int -&gt;  Int 
fastFib = fst . fibPair 

 . 操作符把 fibPair 的返回结果传递给前个函数 fst
</t>
<t tx="andelf.20071223173338.3"></t>
<t tx="andelf.20071223173338.4">[1,2,3,4,1,4] :: [Int]
[True]        :: [Bool]

对于每个包含类型 t 的列表, 它的类型为 [t]

['a','a','b'] :: String
"aab"   :: String

[fac, fastFib]  :: [ Int -&gt; Int ]
[[12,2],[2,12],[]] :: [ [Int] ]

[] 空列表, 符合任何一种列表类型

列表是有序的, 可以有重复元素, 而集合相反

另一种表示列表的方法

[n .. m] 代表 [n,n+1, ... , m] n 大于 m , 则列表为空
[n,p .. m] 代表间隔为 p-n 的递增(减)列表

[2 .. 71]  =  [2,3,4,5,6,7]
[3.1 .. 7.0] =  [3.1,4.1,5.1,6.1]  
['a' .. 'm'] =  "abcdefghijklm" 

[7,6 .. 3]  =  [7,6,5,4,3] 
[0.0,0.3 .. 1.0] =  [0.0,0.3,0.6,0.9]
['a','c' .. 'n']  =  "acegikm"  





</t>
<t tx="andelf.20071223173338.5">首先生成元素, 然后用它们测试并转换到结果的元素

ex 为 [2,4,7]

则

[ 2*n | n&lt;-ex] 为 [4,8,14]

[ 2*n | n &lt;- [2,4,7] ]

[isEven n | n&lt;-ex ] ~&gt; [True,True,False]

n&lt;-ex 叫做生成器 generator
可以为生成器添加测试条件 tests (布尔表达式)

[ 2*n | n &lt;- ex , isEven n , n&gt;3 ]

更复杂的例子

myList = [(x,y) | x&lt;- [1 .. 10],  y&lt;- [10,9 .. 1]]

[ x+y | (x,y) &lt;- myList ]

[ x+y | (x,y)&lt;- myList , x&lt;y]

Main&gt; [ ch | ch&lt;- "8234ehrjasdfh834438uh" , isDigit ch ]
"8234834438"

[] == [x | x&lt;- [2,4 .. 100] , not (isEven x)]</t>
<t tx="andelf.20071223173338.6">type Person = String
type Book   = String

type DataBase = [ (Person, Book ) ]

[ book |  (person,book) &lt;-  exampleBase , person=="Alice" ]

makeLoan  :: Database -&gt;  Person -&gt;  Book -&gt;  Database 
makeLoan dBase pers bk  = [ (pers,bk) ] ++ dBase 

++ 用于连接两个列表

注意在列表理解中的变量会覆盖函数的同名参数</t>
<t tx="andelf.20071223173338.7">多态

有多种类型的函数

length :: [a] -&gt; Int 
这里的 a 是类型变量, 代表任何类型

[Bool] -&gt; Int 叫做 [a] -&gt; Int 的实例

(++) 函数的类型
[a] -&gt; [a] -&gt; [a]
包括 [Int] -&gt; [Int] -&gt; [Int]
但不包括 [Int] -&gt; [Bool] -&gt; [Char]

zip  :: [a]  -&gt;  [b]  -&gt;  [(a,b)] 
unzip  :: [(a,b)]  -&gt;  ([a], [b]) 

类型和定义

id x = x
我们不需要关心它的类型
隐含
id :: a -&gt; a

mystery  (x,y)  =  if  x  then  'c'  else  'd' 
类型为 (a,b) -&gt; Char

使用 :type 检查函数类型

多态和重载

== 的定义

(n,m) == (p,q)
    = (n==p) &amp;&amp; (m==q)
</t>
<t tx="andelf.20071223173338.8">类型的重要性

从类型我们就可以大致猜测函数是干什么的
或者缩小我们的搜索范围

Hugs&gt; (:) 3 [1 .. 5]
[3,1,2,3,4,5]
Hugs&gt; [1,3,5] ++ [2,4,6]
[1,3,5,2,4,6]
Hugs&gt; (!!) [1,3,5] 2
5
Hugs&gt; (!!) [1,3,5] 0
1
Hugs&gt; concat [[2,4],[],[5]]
[2,4,5]
Hugs&gt; length [1 .. 3]
3
Hugs&gt; head [4 .. 7]
4
Hugs&gt; last [4 .. 7]
7

Hugs&gt; tail "test"
"est"
Hugs&gt; init "test"
"tes"
Hugs&gt; replicate 2 "ts"
["ts","ts"]
Hugs&gt; take 3 [1,2,4,5,7]
[1,2,4]
Hugs&gt; drop 3 [1,2,4,5,7]
[5,7]
Hugs&gt; splitAt 5 "ZhangCaiXia"
("Zhang","CaiXia")
Hugs&gt; reverse "Andelf"
"flednA"
Hugs&gt; zip "andelf" "feather"
[('a','f'),('n','e'),('d','a'),('e','t'),('l','h'),('f','e')]
Hugs&gt; unzip $$
("andelf","feathe")
Hugs&gt; and [True, False]
False
Hugs&gt; or [False, True]
True
Hugs&gt; sum [1 .. 100]
5050
Hugs&gt; product [1 .. 10]
3628800
Hugs&gt; product [1 .. 4]
24

其他参见 List.hs</t>
<t tx="andelf.20071223173338.9">type String = [Char]

"baboon"
""
"\99a\116" ~&gt; "cat"
"\nasd\n"

putStr :: String -&gt; IO ()

注意分辨 a 'a' "a"

内建函数 show 和 read

show (2+4) ~&gt; "6"
read "True" ~&gt; True</t>
<t tx="andelf.20071223173338.10"></t>
<t tx="andelf.20071223173338.11"></t>
<t tx="andelf.20071223213358"></t>
<t tx="andelf.20071223213358.1">maxOccurs :: Int -&gt; Int -&gt; (Int,Int)
maxOccurs a b
    | a==b	= (a,2)
    | a&gt; b	= (a,1)
    | a&lt; b	= (b,1)

maxThreeOccurs :: Int -&gt; Int -&gt; Int -&gt; (Int,Int)
maxThreeOccurs a b c
    | a==b &amp;&amp; b==c	= (a,3)
    | a&gt;= b &amp;&amp; c&gt;= b	= maxOccurs a c
    | b&gt;= c &amp;&amp; a&gt;= c	= maxOccurs a b
    | b&gt;= a &amp;&amp; c&gt;= a	= maxOccurs b c</t>
<t tx="andelf.20071224103310">Main&gt; [0,0.1 .. 1]
[0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]

因为在 Haskell 中 0 既是 Int 又是 Float</t>
<t tx="andelf.20071224103342">2 Int
1 [Int]</t>
<t tx="andelf.20071224103650">[2]
[2]
[2,2,2,2 ..... 2]</t>
<t tx="andelf.20071224110147">doubleAll : [Int] -&gt; [Int]
doubleAll lst
    = [ 2*n | n &lt;- lst ]

</t>
<t tx="andelf.20071224110648">[ toUpper ch | ch &lt;- "adfeiweJHJUfdaf" ]
"ADFEIWEJHJUFDAF"

[ toUpper ch | ch &lt;- "adf345 eJHJUfdaf" , isAlpha ch]
"ADFEJHJUFDAF"</t>
<t tx="andelf.20071224120021">divisors :: Int -&gt; [Int]
divisors n
    = [ x | x &lt;- [1 .. n] , n `mod` x== 0 ]


isPrime :: Int -&gt; Bool
isPrime n
    = length (divisors n) == 2</t>
<t tx="andelf.20071224120021.1">matches :: Int -&gt; [Int] -&gt; [Int]
matches a lst
    = [ n | n &lt;- lst , n == a]

elem :: Int -&gt; [Int] -&gt; Bool
elem a lst
    = length (matches a lst) /= 0 

</t>
<t tx="andelf.20071224171541">snd :: (a,b) -&gt; b
sing :: a -&gt; [a]</t>
<t tx="andelf.20071224171541.1">id :: x -&gt; x

Char -&gt; Char</t>
<t tx="andelf.20071224171709">shift :: ((a,b),c) -&gt; (a,(b,c))</t>
<t tx="andelf.20071224220411">duplicate :: String -&gt; Int -&gt; String
duplicate str n
    | n==1	= str
    | n&gt; 1	= duplicate (str ++ str) (n-1)
    | otherwise = error "输入不合法"</t>
<t tx="andelf.20071224221752"></t>
<t tx="andelf.20071224221752.1">  [ [ invertchar ch |  ch &lt;-  line ] |  line &lt;-  pic ] </t>
<t tx="andelf.20071224221752.2">type Position = (Int,Int)
type Image = (Picture, Postion)</t>
<t tx="andelf.20071224221752.3">addPairwise intList1 intList2
    = front ++ rear
      where
      minLength = min (length intList1) (length intList2)
      front     = addPairwise (take minLength intList1)
                              (take minLength intList2)
      rear      = drop minLength intList1 ++ drop minLength intList2

格式类似：
f p1 p2 ... pk
    | g1        = e1
      ...
    | otherwise = er
      where
      v1 a1 .. an = r1
      v2 = r2
      ...

let 表达式

Main&gt; let x = 3+2 in x^2 +2*x -4
31

Main&gt; let x = 3+2 ; y = 5-1 in x^2 + 2*x - y
31

作用范围

文件作用域
isOdd, isEven :: Int -&gt; Bool

isOdd n
    | n&lt;= 0	= False
    | otherwise	= isEven (n-1)

isEven n
    | n&lt; 0	= False
    | n== 0	= True
    | otherwise = isOdd (n-1)

maxsq x y
    | sqx &gt; sqy	    = sqx
    | otherwise	    = sqy
	where
	sqx = sq x
	sqy = sq y
	sq :: Int -&gt; Int
	sq z = z*z

-- 也可以是 sq x = x*x
使用最近的作用域







</t>
<t tx="andelf.20071224221752.4"></t>
<t tx="andelf.20071225180210"></t>
<t tx="andelf.20071225180210.1">pic = ["#.#","..#"]

exPic :: [String] -&gt; Int -&gt; [String]
exPic p n
    | n&gt; 0  = concat [ replicate n (concat [ duplicate [c] n | c&lt;-line]) | line &lt;- p]</t>
<t tx="andelf.20071225212727"></t>
<t tx="andelf.20071225212727.1">mystery x y 
    | x==o  = Y 
    | otherwise  =  x 

等同于

mystery 0 y =  y 
mystery x y =  x 

方程按顺序应用

mystery 0 y =  y 
mystery x _ =  x 

没用到 y , 使用下划线匹配任何类型

joinStrings :: (String,String) -&gt;  String 
joinStrings (stl,st2) = st1 ++  "\t" ++  st2 
</t>
<t tx="andelf.20071225212727.2">Main&gt; 3:[]
[3]
Main&gt; 3:[3,4]
[3,3,4]
Main&gt; 4:3:4:[]
[4,3,4]

 : 运算符是右结合的
所以 x:y:zs = x:(y:zs)
类型 a -&gt; [a] -&gt; [a]

++ 运算
[1] ++ [2,4]
[1,2,4]

模式匹配定义

head :: [a] -&gt; a
head (x:_) = x

tail :: [a] -&gt; [a]
tail (_:x) = x

null :: [a] -&gt; Bool
null []	    = True
null (_:_)  = False

任何非空列表都匹配 (p:ps)
空列表匹配 []

含有 : 的模式应放入括号里

case 结构

firstDigit :: String -&gt; Char
firstDigit st
    = case (digits st) of
	[]	-&gt; '\0'
	(x:_)	-&gt; x
	where
	digits :: String -&gt; String
	digits lst = [n | n&lt;-lst , isDigit n]

case e of
    p1 -&gt; e1
    p2 -&gt; e2
    ...
    pk -&gt; ek











</t>
<t tx="andelf.20071225212727.3">sum :: [Int] -&gt; Int
sum []	    = 0
sum (x:xs)  = x + sum xs</t>
<t tx="andelf.20071225212727.4">基本模板为

func []     = ...
func (x:xs) = ... x ... xs ... fun xs ...

concat :: [[a]] -&gt; [a]
concat []       = []
concat (x:xs)   = x ++ concat xs -- 这里 x , xs 是 [a]

(++) :: [a] -&gt; [a] -&gt; [a]
[]     ++ ys = ys
(x:xs) ++ ys = x:(xs++ys)

elem x []       = False
elem x (y:ys)   = (x==y) || (elem x ys)

但
elem x (x: ys) = True 
elem x (y:ys) = elem x ys 
这样定义是不允许的, Haskell 不允许在匹配模式里有重复变量

同样可以完成 doubleAll selectEven 等例子

插入法排序
iSort :: [Int] -&gt; [Int]
iSort []	    = []
iSort (x:xs) = ins x (iSort xs)
    where
    ins :: Int -&gt; [Int] -&gt; [Int]
    ins x []	    = [x]
    ins x (y:ys)
	| x&lt;= y	    = x:(y:ys)
	| otherwise = y:(ins x ys)


</t>
<t tx="andelf.20071225212727.5">zip :: [a] -&gt; [b] -&gt; [(a,b)]
zip [] []	= []
zip (x:xs) []	= []
zip [] (y:ys)	= []
zip (x:xs) (y:ys) = (x,y) : Main.zip xs ys

take :: Int -&gt; [a] -&gt; [a]
take 0 _	= []
take _ []	= []
take n (x:xs)
    | n&gt; 0    = x : Main.take (n-1) xs
take _ _ = error "XXXXXXXXXXX"

quicksort 算法

qSort :: [Int] -&gt; [Int]
qSort []    = []
qSort (x:xs)
    = qSort [a | a&lt;- xs , a&lt;= x] ++ [x] 
	    ++ qSort [b | b&lt;- xs, b&gt; x]</t>
<t tx="andelf.20071225212727.6">把多行文本填充到指定行宽, 按指定规则在单词中加入空格

-----------------
-- text processing 
-- -----------------

whitespace = ['\r', '\n', '\t', ' ']

split :: String -&gt; [String]
split []    = []
split lst
    = getWord lst : split (dropWord lst)
    where
    getWord, dropWord :: String -&gt; String
    getWord []	= []
    getWord (x:xs)
	| elem x whitespace	= []
	| otherwise		= x : getWord xs    
    dropWord [] = []
    dropWord (x:xs)
	| elem x whitespace	= xs
	| otherwise		= dropWord xs</t>
<t tx="andelf.20071225223038"></t>
<t tx="andelf.20071225223038.1">addFirstTwoDigit :: [Int] -&gt; Int
addFirstTwoDigit lst
    = case (length lst) of
	0	-&gt; 0
	1	-&gt; head lst
	_	-&gt; head lst + head (tail lst)</t>
<t tx="andelf.20071226064144">product :: [Int] -&gt; Int
product [] = 1
product (x:xs) = x * Main.product xs</t>
<t tx="andelf.20071226064601">lst_and, lst_or :: [Bool] -&gt; Bool
lst_and [] = True
lst_and (x:xs)
    | x== True	    = lst_and xs
    | x== False	    = False

lst_or [] = False
lst_or (x:xs)
    | x== True	    = True
    | x== False	    = lst_or xs</t>
<t tx="andelf.20071226071724">elemNum :: Int -&gt; [Int] -&gt; Int
elemNum x lst
    = length [ n | n&lt;- lst , n== x]


---------------------------
elemNum x lst
    = iterElemNum x lst 0
    where
    iterElemNum :: Int -&gt; [Int] -&gt; Int -&gt; Int
    iterElemNum _ [] n	    = n
    iterElemNum a (x:xs) n
	| a==x	    = iterElemNum a xs (n+1)
	| otherwise = iterElemNum a xs n</t>
<t tx="andelf.20071226120801">drop :: Int -&gt; [a] -&gt; [a]
drop 0 lst	= lst
drop n (x:xs)
    | n&gt; 0	= drop (n-1) xs
    | otherwise = error "XXX"

splitAt :: Int -&gt; [a] -&gt; [[a]]
splitAt n [] = [[]]
splitAt n lst = [take n lst, drop n lst]</t>
<t tx="andelf.20071226135648">-- 有错误

subst :: String -&gt; String -&gt; String -&gt; String
subst oldSub newSub st
    = take (find oldSub st) st ++ newSub 
	++ drop (find oldSub st + length oldSub) st 

    where
    -- find oldSub in st
    find :: String -&gt; String -&gt; Int
    find sub st
	| length sub &gt; length st    = error "找个P啊"
	| otherwise		    = findIter sub sub st 0
	where
	findIter :: String -&gt; String -&gt; String -&gt; Int -&gt; Int
	findIter s (x:xs) (y:ys) n
	    | ys== []		= -1
	    | x== y &amp;&amp; xs== []	= n
	    | x== y		= findIter s xs ys n
	    | otherwise		= findIter s s ys (n+1)</t>
<t tx="andelf.20071226145256"></t>
<t tx="andelf.20071226145256.1">在命令行下测试
手工展开计算
直接观察一般情况下函数的行为
</t>
<t tx="andelf.20071226145256.2">边界情况</t>
<t tx="andelf.20071226145256.3">递归程序应该有结束情况
例如 fac (-2)
undefined 和 defined 的值
0*e defined
0*fac (-2) undefined

Haskell 的求值是 lazy 的, 所以函数的参数只在用到时求值
这与 Scheme 不同

可以定义 [1,2 .. ]
部分定义列表

</t>
<t tx="andelf.20071226145256.4">证明中的 Assumption 假设

=&gt; 暗含 implication



</t>
<t tx="andelf.20071226145256.5">定义

列表的结构化归纳原则
有限列表

为了证明一个逻辑属性 P(xs) 对于所有有限列表都成立

Base Case . P([])
Induction Step . 归纳步骤 假定 P(xs) 成立, 证明 P(x:xs) 成立.
也就是证明 P(xs) =&gt; P(x:xs)

P(xs) 叫做归纳假设 induction hypothesis</t>
<t tx="andelf.20071226145256.6">一般证明步骤

reverse (xs ++ ys) = reverse ys ++ reverse xs

Statement

+ Base Case: reverse ([] ++ ys) = reverse ys ++ reverse []
+ Induction Goal: reverse ((x:xs) ++ ys) = reverse ys ++ reverse (x:xs)
+ 需要用假设来证明: reverse (xs ++ ys) = reverse ys ++ reverse xs

</t>
<t tx="andelf.20071226145256.7">shunt :: [a] -&gt; [a] -&gt; [a]
shunt []	 ys	= ys
shunt (x:xs)	 ys	= shunt xs (x:ys)

rev :: [a] -&gt; [a]
rev xs     = shunt xs []

证明 rev (rev xs) = xs</t>
<t tx="andelf.20071226150057"></t>
<t tx="andelf.20071226150057.1">True
未定义</t>
<t tx="andelf.20071226150057.2">mult :: Int -&gt; Int -&gt; Int
mult 0 _    = 0
mult x y    = y + mult (x-1) y

</t>
<t tx="andelf.20071226175906"></t>
<t tx="andelf.20071226175906.1">Applying to all - mapping -&gt; doubleALl
Selecting elements - filtering -&gt; digits
Combining the items - folding -&gt; sum
Breaking up lists -&gt; getWord
Combinations

Haskell 提供了把前置函数转化为内部 infix 格式的方法
inx s [] 
s `inx` []</t>
<t tx="andelf.20071226175906.2">接受函数作为参数的函数

映射 Mapping -&gt; map 函数

map f xs = [ f x | x &lt;- xs ]

或是递归定义

map f []     = []
map f (x:xs) = f x : map f xs

所以 
doubleAll xs = map double xs

输入列表中的元素的类型必须是函数接受的类型
输出列表中的元素类型为函数返回的类型
map :: ( a -&gt; b ) -&gt; [a] -&gt; [b]

通过一个返回 Bool 类型的函数, 为特定类型定义一个 Bool 属性
t -&gt; Bool
有该特性的元素 x , 那么 f x 返回 True

例如 isOdd isEven isSorted
isSorted :: [Int] -&gt; Bool
isSorted xs = (xs == iSort xs)

过滤 - filter 函数
filter p [] = []
filter p (x:xs)
    | p x       = x : filter p xs
    | otherwise =     filter p xs

list comprehension Version
filter p xs = [ x | x &lt;- xs , p x ]

filter :: a -&gt; Bool -&gt; [a] -&gt; [a]










</t>
<t tx="andelf.20071226175906.3">foldr1 :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; a

foldr1 f [x] = x
foldr1 f (x:xs) = f x (foldr1 f xs)

foldr1 (||) [False, True, False] = True


foldr f s [] = s
foldr f s (x:xs) = f x (foldr f s xs)

s 代表 starting value
foldr 中的 r 代表折叠 fold , 直到最右 right

利用 foldr

concat :: [[a]] -&gt; [a]
concat xs = foldr (++) [] xs

and :: [Bool] -&gt; Bool
and bs = foldr (&amp;&amp;) True bs

or :: [Bool] -&gt; Bool
or bs = foldr (||) False bs

foldr 的通用格式

foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b

例如

snoc :: a -&gt; [a] -&gt; [a]
snoc x xs = xs ++ [x]

rev :: [a] -&gt; [a]
rev xs = foldr snoc [] xs

iSort :: [Int] -&gt; [Int]
iSort xs = foldr ins [] xs

从定义中看

foldr f s 为原始递归</t>
<t tx="andelf.20071226175906.4">getUntil :: (a -&gt; Bool) -&gt; [a] -&gt; [a]
getUntil p []     = []
getUntil p (x:xs)
    | p x       = []
    | otherwise = x : getUntil p xs


getWord xs
    = getUntil p xs
      where
      p x = elem x whitespace

getUntil dropUntil takeWhile dropWhile</t>
<t tx="andelf.20071228063723"></t>
<t tx="andelf.20071228063723.1">addOne :: Int -&gt; Int
addOne n    = n + 1

greaterZero :: Int -&gt; Bool
greaterZero  n = n&gt; 1

addUp :: [Int] -&gt; [Int]
addUp ns = map addOne ( filter greaterZero ns)</t>
<t tx="andelf.20071228063856">map f (map g xs)
对 xs 中所有元素应用函数 g 然后对返回的列表应用函数 f</t>
<t tx="andelf.20071228063945">filter p (filter q xs)
xs 中同时具有 p 属性和 q 属性的元素</t>
<t tx="andelf.20071228065930">map square ns
sum (map square ns)
</t>
<t tx="andelf.20071228065930.1">testfunc :: Int -&gt; Int
testfunc 0 = 34
testfunc 1 = 32
testfunc 2 = 45
testfunc 3 = 47
testfunc 4 = 456
testfunc _ = 14

testfunc2 :: Int -&gt; Int
testfunc2 _ = 0

minOfFunc :: (Int -&gt; Int) -&gt; Int -&gt; Int
minOfFunc f n
    | n&gt; 0	= head (iSort (map f [0 .. n]))
    | otherwise = error "....."

isFuncAllEq :: (Int -&gt; Int) -&gt; Int -&gt; Bool
isFuncAllEq f n
    | n&gt; 0	= isAllEq (iSort (map f [0 .. n]))
    | otherwise = error "......."
    where
    isAllEq :: [Int] -&gt; Bool
    isAllEq []	    = True
    isAllEq (x:xs)
	| xs== [] || x== head xs    = isAllEq xs
	| otherwise		    = False

isFuncInc :: (Int -&gt; Int) -&gt; Int -&gt; Bool
isFuncInc f n
    | n&gt; 0	= map f [0 .. n] == iSort (map f [0 .. n])
</t>
<t tx="andelf.20071228070341">iter :: Int -&gt; (a -&gt; a) -&gt; a -&gt; a
iter n f x
    | n== 0	= f x
    | n&gt; 0	= f (iter (n-1) f x)
    | otherwise	= error "....."</t>
<t tx="andelf.20071229073739"></t>
<t tx="andelf.20071229073739.1">返回函数的函数

例如 . 操作符

rotate pic = filpV (flipH pic)

rotate = flipV . flipH

</t>
<t tx="andelf.20071229073739.2">(f . g) x = f (g x)

(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)

(not . not) True</t>
<t tx="andelf.20071229073739.3">twice :: (a -&gt; a) -&gt; (a -&gt; a)
twice f = (f . f)

iter :: Int -&gt; (a -&gt; a) -&gt; (a -&gt; a)
iter n f
    | n&gt; 0      = f . iter (n-1) f
    | otherwise = id

也可以是

iter n f = foldr (.) id (replicate n f)

返回函数的定义

addNum :: Int -&gt; (Int -&gt; Int)
addNum  n = addN
    where
    addN m = n+m

Lambda 符号

\m -&gt; n+m
\ 类似 λ
上边的定义可以写做 addNum n = (\m -&gt; n+m)

anonymous 匿名函数
f x y z = result
中的 f 等同于 \x y z -&gt; result







</t>
<t tx="andelf.20071229073739.4">multiply :: Int -&gt; Int -&gt; Int
multiply = (\x y -&gt; x*y) 

doubleAll :: [Int] -&gt; [Int]
doubleAll = map (multiply 2)

doubleAll = map (multiply 2) xs

multiply 2 是一个 Int -&gt; Int 类型的函数

部分应用的类型

multiply :: Int -&gt; Int -&gt; Int
multiply 2 :: Int -&gt; Int
multiply 2 3 :: Int

函数应用是从左到右运算的 左结合

所以 
f x y =  (f x) y
f x y != f (x y)

"-&gt;" 符号是右结合的, 所以
a -&gt; b -&gt; c
意味着 a -&gt; (b -&gt; c)
而不是 (a -&gt; b) -&gt; c

函数有多少个参数呢?

dropSpace =  dropWhile (member whitespace) 
dropWord  =  dropWhile (not .  member whitespace) 
getWord  = takeWhile (not .  member whitespace) 
where 
member xs x = elem x xs 

(+2) (2+) 接受一个参数, 返回参数加上 2 的值
(&gt;2) 返回一个参数是否大于 2

(3:) 将 3 添加到列表头部

(++"\n") 在字符串的末尾加上换行符
("\n"++) 在字符串开头加上换行符

规则
(op x) y = y op x
(x op) y = x op y

应用 

filter (&gt;0) . map (+1)

</t>
<t tx="andelf.20071229073739.5"></t>
<t tx="andelf.20071229073739.6">doubleAll :: [Int] -&gt; [Int]
doubleAll = map (*2)

isEven = (==0) . (`mod` 2)

getEvens = filter ((==0).(`mod` 2))

getWord xs 
    = getUntil p xs 
    where 
    p x =  elem x whitespace 

getWord xs = getUntil (`elem` whitespace) xs

(`elem` whitespace) x
= x `elem` whitespace
= elem x whitespace</t>
<t tx="andelf.20071229073739.7">逐个接受参数 : curried 形式
一次接受所有参数 : uncurried 形式

multiplyUC :: (Int,Int) -&gt; Int
multiplyUC (x,y) = x*y


curry :: ((a,b) -&gt; c) -&gt; (a -&gt; b -&gt; c)
curry g x y = g (x, y)

curry multiplyUC

uncurry :: (a -&gt; b -&gt; c) -&gt; ((a,b) -&gt; c)
uncuury f (x,y) = f x y

flip :: (a -&gt; b -&gt;c) -&gt; (b -&gt; a -&gt; c)
filp f x y = f y x

flip elem :: [Char] -&gt; Char -&gt; Bool</t>
<t tx="andelf.20071229073825">程序如何被设计出的?

在函数编程中, 数据导向的设计很常见, 我们聚焦于数据结构
data-directed

首先是储存数据的类型
然后是各个函数的类型</t>
<t tx="andelf.20071231155131"></t>
<t tx="andelf.20071231155131.1">flip :: (a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)
flip f = (\x y -&gt; f y x)

Main&gt; flip (/) 4 3
0.75
Main&gt; (/) 4 2
2.0</t>
<t tx="andelf.20080101075405">\m -&gt; elem m " \t\n"</t>
<t tx="andelf.20080101081923">total :: (Int -&gt; Int) -&gt; (Int -&gt; Int)
total f = (\n -&gt; sum [f k | k&lt;- [0 .. n]] ) </t>
<t tx="andelf.20080101082514">slope :: (Float -&gt; Float) -&gt; (Float -&gt; Float)
slope f = (\n -&gt; (f n - f (n-delta)) / delta)
    where
    delta = 0.00001</t>
<t tx="andelf.20080101083309">integrate :: (Float -&gt; Float) -&gt; (Float -&gt; Float -&gt; Float)
integrate f = (\a b -&gt; sum [ f (k/n) * (b-a)/n | k&lt;- [1 .. n]])
    where
    n = 1/0.0001</t>
<t tx="andelf.20080102162808">map (+1) . filter (&gt;(-1))</t>
<t tx="andelf.20080104104355">Principle of extensionality
对于每个参数, 函数 f 和 g 都有相同的值

intensionality 
两个函数只在定义相同的时候相同
不把它们作为黑箱处理

反函数 inverse
 f . g = id
 g . f = id
例如 curry 和 uncurry

幂等 idempotent
f . f = f</t>
<t tx="andelf.20080104104736">证明 f . (g . h) = (f . g) . h

f . (g . h) x
= f ( (g . h) x)
= f (g (h x))

(f . g) . h x
= (f . g) (h x)
= f (g (h x))</t>
<t tx="andelf.20080104104736.1">id . f = f

id . f x
= id (f x)
= f x
</t>
<t tx="andelf.20080104105224"></t>
<t tx="andelf.20080104105224.1">首先理解编程问题
然后计划或设计我们的解决方法
然后些程序
然后求值, 测试

每一步都可以回朔到前一步

理解问题
    问题的输入和输出, 有没有特殊情况
    察看问题的样例, 帮助理解问题
    问题可以解决么, 问题说明是否完整, 有没有需要阐明的问题
    如果有理解它的不同方法, 试着找出最清楚的
    问题自身有结构没有, 它是由几个部分组成的么, 图表可以帮助理解问题么

设计解决方案
    见到过类似问题没? 如果是, 那么可以利用以前的作为指导
    可以设计一个类似但是更简单的问题么? 如果你可以解决它, 那么可以利用它解决现在的问题
    可以对问题做一般化概括么? 
    问题的构建如何? 可以把它分成几个可以独立解决的部分么? 然后思考如何把这些部分合起来
    考虑如何处理输入输出 - 自底向上的方法. 
    语言的标准库提供了什么?
    在脑中设计并修改. 如果你的程序是有用的, 那么它将会被修改很多次

写程序
    尽量使用提供的库函数
    对于其他类型我们可以定义类似的通用函数
    可以从特殊的函数抽象出通用函数
    大多语言可以让你在不同的情况下做决定, Haskell 提供了模式匹配
    递归是解决列表, 数字问题的通用策略. 定义递归函数 f x 需要考虑如果我们已知 f a 的值, 那么...
    List Comprehensions 是解决列表问题的另个记法
    如果不能定义解决你的问题的函数, 试着定义一个简单的, 然后在最终定义中使用这个函数

回映 Reflection
    你可以测试你的解决方案么? 提供一系列测试组
    如果你的测试显示出错误或者 bugs , 试着找出它们的根源, 是什么引起的
    从你犯的错误里学习. 为你的错误创建一个日志, 记录原因. 这会帮助你在以后避免它们
    你能证明你的程序么? 如果不能, 你可以研究下为什么它会产生正确或错误的结果
    你能用不同的方法完成这个问题么?
    如果要求你修改或扩展这个程序, 容易么? 如果很难的话, 你能想出一个容易扩展的解决方法么?
    程序在合理的时间内获得结果么? 如果不是, 那么它的瓶颈在哪? 如何修改你的程序, 使它性能更好.













</t>
<t tx="andelf.20080104110304">========
一般化问题

如何定义列表[1 .. n]?
[1 .. n] = 1 : [2 .. n]

[m .. n]
    | m&gt; n      = []
    | otherwise = m : [m+1 .. n] 

或是 
[1 .. n]
    | 1&gt; n        = []
    | otherwise   = [1 .. n-1] ++ [n]

========
简单化问题

测试回文字符串
simplePalCheck :: String -&gt; Bool
simplePalCheck st = (reverse st == st)

palCheck = simplePalCheck . clean

========
设计的选择

clean = map toSmall . filter notPunct
或
clean st = [ toSmall ch | ch &lt;- st , notPunct ch]
第二种更易懂, 第一种展示了我们使用了函数组合

=======
辅助函数

例如测试一个字符串是否是另个字符串的子串
subseq :: String -&gt; String -&gt; Bool
subseq []     _ = True
subseq (_:_) [] = False
那么一般情况呢? subseq (x:xs) (y:ys)

subseq (x:xs) (y:ys)
    = subseq (x:xs) ys || frontseq (x:xs) (y:ys)

frontseq :: String -&gt; String -&gt; Bool
frontseq []     _   = True
frontseq (_:_)	[]  = False
frontseq (x:xs) (y:ys)
    = (x==y) &amp;&amp; frontseq xs ys



</t>
<t tx="andelf.20080109210844"></t>
<t tx="andelf.20080109210844.1">提高重用性
提高可读性

elemGen :: (a -&gt; a -&gt; Bool) -&gt; a -&gt; [a] -&gt; Bool
elemGen fn a [] = False
elemGen fn a (x:xs) = fn a x || elemGen fn a xs
</t>
<t tx="andelf.20080109210844.2">elem :: a -&gt; [a] -&gt; Bool

只对于有比较函数的类型才适用
我们把函数定义时用到的一系列类型叫做类型类, 或类
例如定义了 == 操作的类型在 equality 类 Eq 中定义

定义 equality 类
class Eq a where
    (==) :: a -&gt; a -&gt; Bool

类型类中的成员叫做 实例 .
内建的 Eq 类的实例包括基本类型 Int , Float , Bool , Char /
另外还有包含 Eq 实例的列表和元组

函数 Int -&gt; Int 类型并不是 Eq 实例, 因为没有算法能确定两个函数的行为相同

Haskell 中的实例有两种意思

如何在函数中使用 equality 
=========================

allEqual :: Int -&gt; Int -&gt; Int -&gt; Bool
allEqual m n p = (m==n) &amp;&amp; (n==p)
修改为

allEqual :: Eq a =&gt; a -&gt; a -&gt; a -&gt; Bool
allEqual m n p = (m==n) &amp;&amp; (n==p)

在 =&gt; 的部分叫做正文 context , 意思就是这个类型是 Eq 类的实例

Hugs 自动会把未定义类型的函数扩展为最通用的类型

例如
inc x = x+2

输入 :t
inc :: Num a =&gt; a -&gt; a
</t>
<t tx="andelf.20080109210844.3">class Visible a where
      toString :: a -&gt; String
      size     :: a -&gt; Int

定义了类名 Visible , 然后是 signature 一列名字和它们的类型
任何 Visible 类中的类型 a 必须实现 signature 中的函数

定义类的实例
============

通过定义类型的 signature 函数定义类的实例/类型, 例如

instance Eq Bool where
    True == True = True
    False == False = True
    _	== _	    = False

定义 Bool 如何成为 Eq 的实例的

instance Visible Char where
	 toString ch = [ch]
	 size _	     = 1

instance Visible a =&gt; Visible [a] where
    toString = concat . map toString
    size     = foldr (+) 1 . map size

-- 如果一个列表是由 Visible 对象组成的, 那么它本身就是 Visible 对象

实例定义的右边, =&gt; 右边的类型必须是基本类型或是使用 [...] (...,...) 的列表和元组对象
不能用 type 定义的缩略格式

默认定义
=======

equality 例子, Haskell 中这样定义

class Eq a where
    (==), (/=) :: a -&gt; a -&gt; Bool
    x /= y  = not (x==y)
    x == y  = not (x/=y)

根据 == 定义不等, 根据 /= 定义相等
它们会被实例的定义所覆盖, 这样实例定义中只需要提供任意一个即可


继承类
======

class Eq a =&gt; Ord a where
    (&lt;), (&lt;=), (&gt;), (&gt;=) :: a -&gt; a -&gt; Bool
    max, min		 :: a -&gt; a -&gt; a
    compare		 :: a -&gt; a -&gt; Ordering


我们可以提供一些默认定义
例如
x &lt;= y	    = (x &lt; y || x == y)
x &gt;  y	    = y &lt; x
iSort 中使用了 Ord 类
iSort :: Ord a =&gt; [a] -&gt; a

多重约束
========
之前我们看到的例子都是单一约束条件

vSort = toString . iSort
vSort :: (Ord a, Visible a) =&gt; [a] -&gt; String

也可以在实例定义中使用多重约束

instance (Eq a, Eq b) =&gt; Eq (a,b) where
    (x,y) == (z,w)    =	x==z &amp;&amp; y==w

类定义中的多重约束(多重继承) , 这时候使用为空的 signature

class (Ord a, Visible) =&gt; OrdVis a

这样就可以直接定义 vSort
vSort :: OrdVis a =&gt; [a] -&gt; String
</t>
<t tx="andelf.20080109210844.4">Equality : Eq
=============
class Eq a where
    (==), (/=) :: a -&gt; a -&gt; Bool
    x /= y     = not (x==y)
    x == y     = not (x/=y)

Ordering : Ord 有序类型
==============

class (Eq a) =&gt; Ord a where
    compare		     :: a -&gt; a -&gt; Ordering
    (&lt;), (&lt;=), (&gt;=), (&gt;)     :: a -&gt; a -&gt; Bool
    max, min		     :: a -&gt; a -&gt; a

Ordering 类型包含 LT EQ GT ， 代表 Ordering 中比较两个元素可能得到的三种结果
默认定义:
compare x y
    | x == y	= EQ
    | x &lt;= y	= LT
    | otherwise = GT

x &lt;= y	    = compare x y /= GT
x &lt;  y	    = compare x y == LT
x &gt;= y	    = compare x y /= LT
x &gt;  y	    = compare x y == GT

max x y
    | x &gt;= y	= x
    | otherwise = y
min x y
    | x &lt;= y	= x
    | otherwise = y
大多 Haskell 类型属于 equality 和 ordering 类, 包括异常和函数类型, 以及其他数据类型(chpt 16)

Enumeration: Enum
=================

enumeration 表达式
[2,4 .. 8]
可以用在其他类型, 字符, 浮点数, 以及其他.

class (Ord a) =&gt; Enum a where
    | toEnum	    :: Int -&gt; a
    | fromEnum	    :: a -&gt; Int
    | enumFrom	    :: a -&gt; [a]		-- [n .. ]
    | enumFromThen  :: a -&gt; a -&gt; [a]	-- [n,m .. ]
    | enumFromTo    :: a -&gt; a -&gt; [a]	-- [n .. m]
    | enumFromThenTO:: a -&gt; a -&gt; a -&gt; [a] -- [n,n' .. m]

enumFromTo 和 enumFromThenTO 有默认定义
toEnum 和 fromEnum 用于转换类型
ord :: Char -&gt; Int
ord = fromEnum

chr :: Int -&gt; Char
chr = toEnum
并不是所有 Enum 类型的 toEnum 和 fromEnum 都有定义
例如实数和全精度数, 会导致 run-time error
successor 和 predecessor 函数
succ, pred :: Enum a =&gt; a -&gt; a
succ = toEnum . (+1) . fromEnum
pred = toEnum . (subtract 1) . fromEnum

有界类型: Bounded
=================

class Bounded a where
    minBound, maxBound :: a

Int , Char , Bool , Ordering 属于这个类

将值转换为字符串: Show
======================

type ShowS = String -&gt; String

class Show a where
    showsPrec :: Int -&gt; a -&gt; ShowS
    show      :: a -&gt; String
    showList  :: [a] -&gt; ShowS

showsPrec 用于大数据值, 但使用介绍性的格式??
show 把值转换为字符串
函数默认从 show 定义 showsPrec , 从 showsPrec 定义 show

instance Show Bool where
    show True  = "True"
    show False = "False"

instance (Show a, Show b) =&gt; Show (a,b) where
    show (x,y) = "(" ++ show x ++ "," ++ show y ++ ")"

把字符串转换为值: Read
======================
可从字符串获得值
read :: (Read a) =&gt; String -&gt; a
结果是未定义的
我们可以使用
(read "       1 " ):: Int

Haskell 中的数值类型
===================
固定精度整数 Int 全精度整数 Integer
浮点数 Float 双精度 Double
有理数, 分数 Rational ( Integer 分数 )
Complex 

Int 和 Integer 使用相同的操作符, 相同的文字表示
同样地 Float Double

也可以使用显式类型限制表达式
(2+3)::Int

class (Eq a, Show a) =&gt; Num a where
    (+), (-), (*) :: a -&gt; a -&gt; a
    negate	:: a -&gt; a
    abs, signum	:: a -&gt; a
    fromInteger	:: Integer -&gt; a
    fromInt	:: Int -&gt; a

    x - y   = x + negate y
    fromInt = fromIntegral

字面常量可以是任何类型
2 :: Num a =&gt; a

Integral 类型的函数
quot, rem :: a -&gt; a -&gt; a
div, mod  :: a -&gt; a -&gt; a
区别在于
&gt; quot (-32) 3
-10
&gt; div (-32) 3
-11

2.3 :: Fractional a =&gt; a
class (Num a) =&gt; Fractional a where
    (/)	    :: a -&gt; a -&gt; a
    recip   :: a -&gt;
    fromRational :: Rational -&gt; a

    recip x = 1 / x

Floating 函数:
pi exp log sqrt (**) logBase sin cos 等


</t>
<t tx="andelf.20080109210844.5">Haskell 类型类和面向对象编程中类的关系

Haskell 类型系统. 多态类型:
    show :: Show a =&gt; a -&gt; String

In Haskell a class is a collection of types.

Other language make a type and a class the same thing.
e.g. :
    show :: ShowType -&gt; String

动态绑定, 非 Haskell 98 特性. 

</t>
<t tx="andelf.20080111114655"></t>
<t tx="andelf.20080111114655.1">Eq</t>
<t tx="andelf.20080113221441">Main.compare :: (Visible a, Visible a1) =&gt; a -&gt; a1 -&gt; Bool
</t>
<t tx="andelf.20080113222955">int2str :: Int -&gt; String
int2str 0 = ""
int2str n = int2str (div n 10) ++ [intToDigit (mod n 10)]


instance Visible Int where
	 toString = int2str
	 size _ = 1

</t>
<t tx="andelf.20090716095801.1530"></t>
<t tx="andelf.20090716095801.1531">+(int) :: Int -&gt; Int -&gt; Int
length(char) :: [Char] -&gt; Int

</t>
<t tx="andelf.20090716095801.1532">lengt :: [a] -&gt; Int
包含:
    [Int] -&gt; Int
    [(Bool,Char)] -&gt; Int
    ....

给类型加入限制(constraints)</t>
<t tx="andelf.20090716095801.1533"></t>
<t tx="andelf.20090716095801.1534">f n      =  37+n   
f  True  =  34 
其中
f :: Num a =&gt; a -&gt; a
f :: Bool -&gt; Int

g  0  =  37 
g  n  =  True 
返回类型冲突

k x = 34
k 0 = 35
无类型错误
</t>
<t tx="andelf.20090716095801.1535"></t>
<t tx="andelf.20090716095801.1536">* 枚举类型

</t>
</tnodes>
</leo_file>
